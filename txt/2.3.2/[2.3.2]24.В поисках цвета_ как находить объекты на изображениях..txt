Ваня на диване смотрит видеоролики на телефоне и начинает задумываться
Ваня: Интересно, а можно ли научить компьютер находить объекты на изображениях по цвету? Как мы быстро находим все желтые машины на улице или зеленые яблоки в магазине.
Нейросеточка (появляется в телефоне): Ваня, это уже реализовано в различных приложениях и технологиях компьютерного зрения.Ты с одним из таких решений уже сталкивался.
Ваня: А, да точно, я же начал изучать библиотеку OpenCV. Но как она используется для нахождения объектов по цвету? Пока не понимаю…
Нейросеточка: OpenCV часто используется для поиска объектов по цвету с помощью метода пороговой сегментации. Пороговая сегментация - это метод, в котором устанавливается пороговое значение для разделения изображения на две части. Пиксели выше порога считаются частью объекта, а пиксели ниже — частью фона. Если мы хотим найти объекты определенного цвета, то мы указываем определенный диапазон цветовых значений, например, оттенки красного. Пороговая сегментация отмечает все пиксели на изображении, находящиеся в этом заданном диапазоне, рассматривая их как возможные объекты.
Ваня: Понятно. То есть я могу задать диапазон красных оттенков, а OpenCV выделит все красные элементы на изображении? Например, обнаружит созревшую землянику среди остальных неспелых на поляне?
Нейросеточка: Именно так! Хороший пример с ягодой. Такая простая задача в области компьютерного зрения может стать отличным началом для твоих экспериментов.
Ваня: Звучит увлекательно! Я хочу попробовать метод пороговой сегментации на практике!
Нейросеточка: Отлично! Начнем с разработки плана действий для поиска объектов на изображениях. Обратимся к Гигачату.
Промпт: Напиши алгоритм, как искать объекты одного цвета на изображении с помощью OpenCV.
Результат: Основные шаги поиска объектов по цвету включают:
Преобразование изображения в нужное цветовое пространство. Цветовые пространства помогают представлять цвета в форме, удобной для обработки и анализа.
Построение трехмерного графика цветового рассеивания. Визуализация распределения цветов на изображении помогает определить структуру данных цветового пространства
Установка порогов для поиска. Задание диапазона цветов, которые должны быть обнаружены.
Маскирование изображения. Создание бинарной маски, где пиксели, соответствующие заданному диапазону цветов, имеют значение 1, а остальные 0.
Ваня: Значит, нужно начать с цветовых пространств! Я помню, что модель RGB наиболее популярна и поэтому о других я не слышал.
Нейросеточка: Ваня, давай это исправлять! Познакомимся с цветовым пространством HSV, которое описывает цвет с помощью трех параметров: оттенок (Hue), насыщенность (Saturation) и яркость (Value). Оттенок представляет собой сам цвет и измеряется в градусах от 0 до 360. Насыщенность показывает, насколько цвет является чистым или близким к белому, измеряется в процентах. А яркость определяет общую яркость цвета и измеряется в процентах.
ШАГ 1. Настройка рабочей среды
Нейросеточка: Прежде чем приступить к преобразованию изображения в нужное цветовое пространство, необходимо выполнить следующие шаги:
Создать новую папку “Segmentation”.
В Visual Studio Code в левом верхнем углу нажать кнопку «File», выбрать «Open folder», затем выбрать на компьютере созданную папку «Segmentation» и нажать “Выбор папки”.
Создать в папке “Segmentation” новый файл с расширением .py, а также добавить эту папку все необходимые для урока изображения.
Убедиться, что установлены библиотеки OpenCV, MathPlotLib и Numpy.
Рассказчик: Если matplotlib или numpy ещё не установлены - воспользуйтесь командами для установки (или проверки наличия) данных библиотек. Они находятся в материалах к занятию.
Задание: Настройте рабочую среду, выполнив все рекомендации.
ПАУЗА
ШАГ 2. Преобразование изображения в нужное цветовое пространство.
Нейросеточка: Теперь, когда рабочая среда настроена, возьмем одну из подготовленных картинок под названием tiger1.png и преобразуем её в цветовое пространство HSV.

Рассказчик: Все картинки и дальнейший код доступны в материалах к занятию.
Ваня: Вау, на картинке изображен бенгальский тигр! У него яркий оранжевый окрас с черными полосами. Мы будем фильтровать эти цвета на изображении?
Нейросеточка: Все верно! Нас интересуют оттенки оранжевого и белого, а темные участки пока учитывать не будем. Для начала подключим библиотеки OpenCV - для обработки нашего изображения, MatPlotLib - для построения графиков и NumPy для вычислений.
import cv2
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import colors
Нейросеточка: OpenCV по умолчанию использует цветовое пространство BGR, оно аналогично RGB, но цвета расположены в другом порядке.
Для этого выполним следующие команды:
tiger = cv2.imread('tiger1.png')
tiger = cv2.cvtColor(tiger, cv2.COLOR_BGR2RGB)
hsv_tiger = cv2.cvtColor(tiger, cv2.COLOR_RGB2HSV)
Ваня: Я понял логику этого фрагмента. А после знака равенства это вызовы функций?
Нейросеточка: Совершенно верно! Функция “imread” загружает изображение в формате BGR, а последующие функции выполняют преобразование в новые форматы цветового пространства.
Задание: Выполните преобразование изображения в HSV, применив данный код.
ПАУЗА
ШАГ 3. Построение трехмерного графика цветового рассеивания
Ваня: Ой, это звучит как-то страшно и сложно!
Нейросеточка: Не волнуйся, Ваня! Мы построим трехмерный график, где каждая точка представляет собой цвет изображения в пространстве HSV. Вот такой кусочек кода нам понадобится:
h, s, v = cv2.split(hsv_tiger)
fig = plt.figure()
axis = fig.add_subplot(1, 1, 1, projection="3d")
Рассказчик: Этот фрагмент разделяет изображение в цветовом пространстве HSV на отдельные каналы: H (оттенок), S (насыщенность) и V (значение яркости). Затем он создает трехмерный график, где ось X соответствует каналу H, ось Y - каналу S и ось Z - каналу V. Это поможет визуализировать значения каждого канала в пространстве и лучше понять, как они взаимодействуют между собой в изображении.
Ваня: Действительно, несложно! Но мне кажется, что цвета на графике не будут показаны в привычном RGB-формате и мы не сможем увидеть наши оттенки оранжевого и белого.
Нейросеточка: Ты прав. Для того чтобы правильно отобразить цвета, мы заранее раскрасим точки на графике в нужные оттенки, используя переменную “pixel_colors”. А затем построим трехмерный график.
pixel_colors = tiger.reshape((np.shape(tiger)[0]*np.shape(tiger)[1], 3))
norm = colors.Normalize(vmin=-1.,vmax=1.)
norm.autoscale(pixel_colors)
pixel_colors = norm(pixel_colors).tolist()
axis.scatter(h.flatten(), s.flatten(), v.flatten(), facecolors=pixel_colors, marker=".")
axis.set_xlabel("Hue")
axis.set_ylabel("Saturation")
axis.set_zlabel("Value")
plt.show()

Ваня: Сколько строк! Подожди, я хочу разобраться — напишу Гигачату.
Промпт: Объясни этот код кратко.
pixel_colors = tiger.reshape((np.shape(tiger)[0]*np.shape(tiger)[1], 3))
norm = colors.Normalize(vmin=-1.,vmax=1.)
norm.autoscale(pixel_colors)
pixel_colors = norm(pixel_colors).tolist()
axis.scatter(h.flatten(), s.flatten(), v.flatten(), facecolors=pixel_colors, marker=".")
axis.set_xlabel("Hue")
axis.set_ylabel("Saturation")
axis.set_zlabel("Value")
plt.show()
Результат: Этот код создает цветовой спектр изображения тигра с использованием библиотек NumPy и Matplotlib.
Создается переменная pixel_colors, содержащая цвета каждого пикселя изображения тигра. С помощью функции reshape эта переменная преобразуется в нужный формат.
Используется инструмент Normalize из Matplotlib для нормализации значений цветов, чтобы они находились в определенном диапазоне.
Происходит нормализация цветов каждого пикселя и их преобразование в список.
Далее используется функция scatter из Matplotlib для визуализации цветовых спектров каждого пикселя.
Устанавливаются названия осей графика и отображается результат.
Нейросеточка: Посмотри какой график получился.

Ваня: Классный! Видно, что оранжевый цвет скапливается в одном месте. А как выбрать нужный диапазон?
ШАГ 4. Установка порогов для поиска.
Нейросеточка: Для определения нужного диапазона оранжевого цвета нам нужно установить пороговые значения. Давай оценим значения по осям на графике.
Рассказчик: Чтобы поворачивать график, используйте левую кнопку мыши, удерживая её нажатой и двигая мышь. Это может происходить с небольшой задержкой — это нормально.
Нейросеточка: Посмотрим на график под разными углами:
По оси Hue (оттенок) нужные оттенки оранжевого лежат в диапазоне примерно от 11 до 19. Можно также взять 10-20 или 9-21 — значения всегда будут приблизительными.
По осям Saturation (насыщенность) и Value (яркость) подходящие значения — примерно от 80 до 255 для насыщенности и от 0 до 255 для яркости

Мы охватываем весь диапазон яркости, так как на тигре есть черные полосы, и хотим включить темный оттенок оранжевого в пороговые значения.
Рассказчик: Для более точных значений посмотрите в правый нижний угол графика, наведя мышкой на нужную область графика (интересуют только целые числа).
Ваня: Тогда нужно составить светлую и темную версию, прописав в каждом три целых числа!
Нейросеточка: Верно,тогда мы получаем значения нижнего и верхнего порога оранжевого цвета.
light_orange = (11, 80, 0)
dark_orange = (19, 255, 255)
Задание: Попробуйте таким же образом определить пороговые значения белого цвета, используя всё тот же график цветового рассеивания.
ПАУЗА
Рассказчик: Примерно такие пороговые значения для белого цвета у вас должны получиться.
light_white = (1, 0, 0)
dark_white = (175, 7, 255)
ШАГ 5. Маскирование изображения
Нейросеточка: Теперь, когда у нас есть пороговые значения для оранжевого и белого цветов, перейдем к сегментации изображения по выбранным цветам. Предлагаю создать новый файл, убрав из кода расчеты для построения трехмерного графика.
Рассказик: Обновленный код доступен в материалах к занятию.
Нейросеточка: На основе этих диапазонов создадим маски, которые будут накладываться на наше изображение, оставляя только выбранные цвета.
mask_orange = cv2.inRange(hsv_tiger, light_orange, dark_orange)
mask_white = cv2.inRange(hsv_tiger, light_white, dark_white)
final_mask = mask_orange + mask_white
Ваня: "final_mask" забавная переменная! Это объединение масок оранжевого и белого для того, чтобы оба этих цвета были видны в итоговом результате?
Нейросеточка: Именно так! И затем сформируем итоговое изображение, применив маски, и отобразим их на экране. Далее запустим код и посмотрим результат.
final_result = cv2.bitwise_and(tiger, tiger, mask=final_mask)
plt.imshow(final_result)
plt.show()

Рассказчик:На изображении видны не только части тигра, но и другие элементы из-за совпадения цветов объекта с фоном. Этот эффект можно частично устранить более точным выбором цветовых диапазонов, но если такие же цвета встречаются где-то еще, они все равно будут отображены.
Ваня: Прикольно, я теперь знаю, как научить компьютер находить объекты на изображениях по цвету!
Сегодня на занятии вы:
Познакомились с пороговой сегментацией
Узнали новые модели цветового пространства
Научились строить трехмерный график цветового рассеивания
Приобрели навык установки порогов для поиска
Научились создавать маски

Вы хорошо потрудились! Увидимся на следующем занятии!